#!/usr/bin/env node

// src/index.ts
import { program } from "commander";

// src/lib/analyser.ts
import { traverse } from "@babel/types";

// src/lib/logger.ts
import chalk from "chalk";
var warn = (...content) => {
  console.log(chalk.gray(content));
};

// src/lib/analyser.ts
var findExportedIdentifiers = (file) => {
  const exports = [];
  traverse(file.ast, {
    enter(path3) {
      switch (path3.type) {
        case "ExportDefaultDeclaration":
          exports.push("default");
          break;
        case "ExportNamedDeclaration":
          if (path3.declaration?.type === "VariableDeclaration") {
            exports.push(
              ...path3.declaration.declarations.map((decl) => decl.id.type === "Identifier" ? decl.id.name : void 0).filter(Boolean)
            );
          }
          if (path3.specifiers) {
            exports.push(
              ...path3.specifiers.map((specifier) => specifier.exported.type === "Identifier" ? specifier.exported.name : void 0).filter(Boolean)
            );
          }
          break;
        case "ExpressionStatement":
          if (path3.expression.type !== "AssignmentExpression")
            return;
          if (path3.expression.left.type !== "MemberExpression")
            return;
          if (path3.expression.left.object.type !== "Identifier" || path3.expression.left.object.name !== "module")
            return;
          if (path3.expression.right.type === "Identifier") {
            exports.push("default");
          } else if (path3.expression.right.type === "ObjectExpression") {
            path3.expression.right.properties.forEach((prop) => {
              if (prop.type === "ObjectProperty") {
                if (prop.key.type === "Identifier") {
                  exports.push(prop.key.name);
                } else if (prop.key.type === "StringLiteral") {
                  exports.push(prop.key.value);
                }
              }
            });
          }
          break;
      }
    }
  });
  return exports;
};
var getRequire = (path3) => {
  if (path3.type !== "CallExpression")
    return;
  if (path3.callee.type !== "Identifier")
    return;
  if (path3.callee.name !== "require")
    return;
  if (path3.arguments.length !== 1)
    return;
  if (path3.arguments[0].type !== "StringLiteral")
    return;
  const arg = path3.arguments[0];
  return {
    ...path3,
    type: "CallExpression",
    callee: { ...path3.callee, name: "require" },
    arguments: [arg]
  };
};
var findImportedIdentifiers = (file) => {
  const imports = [];
  traverse(file.ast, {
    enter(path3) {
      switch (path3.type) {
        case "ImportDeclaration":
          imports.push(
            ...path3.specifiers.map((specifier) => {
              if (specifier.type === "ImportSpecifier") {
                const as = specifier.imported.type === "Identifier" ? specifier.imported.name : specifier.imported.value;
                return { as, from: path3.source.value };
              } else if (specifier.type === "ImportDefaultSpecifier") {
                return { as: "default", from: path3.source.value };
              }
            }).filter(Boolean)
          );
          break;
        case "ExportNamedDeclaration":
          if (path3.source) {
            if (path3.source.type === "StringLiteral") {
              imports.push(...path3.specifiers.map((specifier) => {
                if (specifier.type === "ExportSpecifier") {
                  return {
                    as: specifier.local.name,
                    from: path3.source.value
                  };
                } else {
                  return {
                    as: "default",
                    from: path3.source.value
                  };
                }
              }));
            }
          }
          break;
        case "VariableDeclaration":
          const type = "cjs";
          path3.declarations.forEach((decl) => {
            if (decl.type === "VariableDeclarator") {
              const requireCall = decl.init ? getRequire(decl.init) : void 0;
              if (!requireCall)
                return;
              const from = requireCall.arguments[0].value;
              if (decl.id.type === "Identifier") {
                imports.push({ as: "default", from, type });
              } else if (decl.id.type === "ObjectPattern") {
                decl.id.properties.forEach((prop) => {
                  if (prop.type === "ObjectProperty") {
                    if (prop.key.type === "Identifier") {
                      imports.push({ as: prop.key.name, from, type });
                    } else if (prop.key.type === "StringLiteral") {
                      imports.push({ as: prop.key.value, from, type });
                    }
                  }
                });
              }
            }
          });
          break;
        case "ExpressionStatement":
          if (path3.expression.type === "AssignmentExpression") {
            const requireCall = getRequire(path3.expression.right);
            if (!requireCall)
              return;
            const from = requireCall.arguments[0].value;
            imports.push({ as: "default", from, type: "cjs" });
          } else if (path3.expression.type === "MemberExpression") {
            const requireCall = getRequire(path3.expression.object);
            if (!requireCall)
              return;
            const from = requireCall.arguments[0].value;
            imports.push({ as: "default", from, type: "cjs" });
          }
          break;
        case "CallExpression":
          if (path3.callee.type === "Import") {
            const fromArg = path3.arguments[0];
            if (fromArg.type === "StringLiteral") {
              imports.push({
                as: "*",
                // Special case, too hard to determine what is imported so just assume everything
                from: fromArg.value,
                type: "esm"
              });
            }
          } else {
            let requireCall2 = getRequire(path3.callee);
            if (!requireCall2) {
              for (const arg of path3.arguments) {
                requireCall2 = arg.type === "CallExpression" ? getRequire(arg) : void 0;
                if (requireCall2)
                  break;
              }
            }
            if (!requireCall2)
              return;
            const from2 = requireCall2.arguments[0].value;
            imports.push({ as: "default", from: from2, type: "cjs" });
          }
      }
    }
  });
  return imports.map((importInfo) => {
    const path3 = importInfo.from.replace(/\.[^/.]+$/, "");
    return { ...importInfo, from: path3 };
  });
};
var splitPath = (path3) => path3.split("/").filter(Boolean);
var resolvePathAlias = (paths, pathSegments) => {
  let resolveds = [];
  Object.keys(paths).forEach((alias) => {
    const aliasSegments = splitPath(alias);
    const tempPathSegments = [...pathSegments];
    let wildCard;
    let specifity = 0;
    while (tempPathSegments.length > 0) {
      if (tempPathSegments[0] === aliasSegments[0]) {
        aliasSegments.shift();
        tempPathSegments.shift();
        specifity++;
      } else if (aliasSegments[0] === "*") {
        aliasSegments.shift();
        wildCard = tempPathSegments.shift();
      } else {
        break;
      }
    }
    if (aliasSegments.length === 0) {
      resolveds = resolveds.filter((r) => r.specifity >= specifity);
      const resolvedPaths = paths[alias];
      if (resolvedPaths) {
        resolveds.push(
          ...resolvedPaths.map((resolvedPaths2) => ({
            segments: splitPath(resolvedPaths2).map((segment) => wildCard && segment === "*" ? wildCard : segment).concat(tempPathSegments),
            specifity
          }))
        );
      }
    }
  });
  return resolveds.map((r) => r.segments);
};
var analyse = (root, standardLib, allowDevDeps = false) => {
  const allSourceFiles = [];
  const walkFiles = (file, path3 = []) => {
    if (file.type === "file") {
      const exports = findExportedIdentifiers(file);
      const imports = findImportedIdentifiers(file);
      file.moduleInfo = { exports, unusedExports: [...exports], imports };
      allSourceFiles.push(file);
    } else {
      file.children.forEach((child) => walkFiles(child, [...path3, child.name]));
    }
  };
  walkFiles(root);
  const markImport = (file, importInfo) => {
    if (file.moduleInfo?.unusedExports) {
      if (importInfo.type === "cjs" && importInfo.as === "default") {
        file.moduleInfo.unusedExports = [];
        return;
      }
      if (importInfo.type === "esm" && importInfo.as === "*") {
        file.moduleInfo.unusedExports = [];
        return;
      }
      file.moduleInfo.unusedExports = file.moduleInfo.unusedExports.filter((exportName) => exportName !== importInfo.as);
    }
  };
  const findAndMarkImport = (file, relativePathSegments, importInfo) => {
    const [segment, ...rest] = relativePathSegments;
    if (segment === void 0) {
      if (file.type === "file") {
        markImport(file, importInfo);
        return true;
      } else {
        const indexFile = file.children.find((child) => child.name.startsWith("index."));
        if (indexFile?.type === "file") {
          markImport(indexFile, importInfo);
          return true;
        } else {
          warn(`Could not find index file for ${file.name}`, importInfo.from);
          return false;
        }
      }
    } else if (segment === ".") {
      return findAndMarkImport(file, rest, importInfo);
    } else if (segment === "..") {
      if (file.parent) {
        return findAndMarkImport(file.parent, rest, importInfo);
      } else {
        warn(`Could not find parent for ${file.name}`);
        return false;
      }
    } else {
      if (file.type === "file") {
        warn(`Could not find child ${segment} for ${file.name} (is not a directory)`);
        return false;
      }
      const matchingChildren = file.children.filter((child) => child.name.match(new RegExp(`^${segment}\\.?`)));
      const childFile = matchingChildren.find((f) => f.type === "file");
      const childDir = matchingChildren.find((f) => f.type === "directory");
      if (rest.length === 0 && childFile) {
        return findAndMarkImport(childFile, rest, importInfo);
      } else if (childDir) {
        return findAndMarkImport(childDir, rest, importInfo);
      } else {
        warn(`Could not find child ${segment} for ${file.name} (${importInfo.from})`);
        return false;
      }
    }
  };
  const findAndMarkNonRelativeImport = (file, pathSegments, importInfo) => {
    const baseUrl = splitPath(file.configs.find((c) => Boolean(c.config.compilerOptions?.baseUrl))?.config?.compilerOptions?.baseUrl ?? "");
    const aliases = file.configs.find((c) => Boolean(c.config.compilerOptions?.paths))?.config?.compilerOptions?.paths ?? {};
    const packageJsonAliases = file.configs.find((c) => Boolean(c.config._moduleAliases))?.config?._moduleAliases ?? {};
    const packageJsonDeps = file.configs.find((c) => Boolean(c.config.dependencies))?.config?.dependencies ?? {};
    if (allowDevDeps) {
      Object.assign(packageJsonDeps, file.configs.find((c) => Boolean(c.config.devDependencies))?.config?.devDependencies ?? {});
    }
    const resolvedPaths = resolvePathAlias(aliases, pathSegments);
    if (Object.keys(packageJsonDeps).some((dep) => splitPath(dep)[0] === splitPath(importInfo.from)[0])) {
    } else if (standardLib.includes(splitPath(importInfo.from)[0]) || importInfo.from.startsWith("node:")) {
    } else if (packageJsonAliases[pathSegments[0]]) {
      const aliasedSegments = splitPath(packageJsonAliases[pathSegments[0]]);
      findAndMarkImport(file, [".", ...aliasedSegments, ...pathSegments.slice(1)], importInfo);
    } else if (resolvedPaths.length > 0) {
      for (const resolved of resolvedPaths) {
        const segments = [...baseUrl, ...resolved];
        if (findAndMarkImport(file, segments, importInfo)) {
          break;
        }
      }
    } else if (baseUrl.length > 0) {
      findAndMarkImport(file, [".", ...baseUrl, ...pathSegments], importInfo);
    } else if (file.parent) {
      findAndMarkNonRelativeImport(file.parent, pathSegments, importInfo);
    } else {
      console.error(`Could not find dependency ${importInfo.from} (${pathSegments})`);
    }
  };
  const walkImports = (file, path3 = []) => {
    if (file.type === "file") {
      file.moduleInfo?.imports.forEach((importInfo) => {
        const pathSegments = splitPath(importInfo.from);
        if (!file.parent) {
          warn(`Could not find parent for ${file.name}. Outside scan range.`);
          return;
        }
        if (pathSegments[0].startsWith(".")) {
          findAndMarkImport(file.parent, pathSegments, importInfo);
        } else {
          findAndMarkNonRelativeImport(file.parent, pathSegments, importInfo);
        }
      });
    } else {
      file.children.forEach((child) => walkImports(child, [...path3, child.name]));
    }
  };
  walkImports(root);
  return allSourceFiles;
};

// src/lib/fileStore.ts
import fs from "fs";
import path from "path";
var evalJsonObject = (source) => {
  return eval(`const a = ${source}; a`);
};
var readDir = async (dir, extensions, ignore) => {
  const cwd = process.cwd();
  const rootPath = path.join(cwd, dir);
  const files = await fs.promises.readdir(rootPath);
  const results = await Promise.all(files.filter(
    (file) => !ignore.includes(file)
  ).map(async (file) => {
    const filePath = path.join(dir, file);
    const stats = await fs.promises.stat(filePath);
    if (stats.isDirectory()) {
      return {
        type: "directory",
        name: file,
        path: filePath,
        children: (await readDir(filePath, extensions, ignore)).children
      };
    } else if (file.match(new RegExp(`\\.(${extensions.join("|")})$`))) {
      return {
        type: "file",
        name: file,
        path: filePath,
        content: await fs.promises.readFile(filePath, "utf-8")
      };
    } else if (file.match(new RegExp(`(tsconfig|jsconfig|package).json`))) {
      return {
        type: "config",
        name: file,
        path: filePath,
        config: evalJsonObject(await fs.promises.readFile(filePath, "utf-8"))
      };
    } else {
      return null;
    }
  }));
  const rootDirectory = {
    type: "directory",
    name: dir,
    path: rootPath,
    children: results.filter(Boolean)
  };
  return rootDirectory;
};

// src/lib/parser.ts
import { parse } from "@babel/parser";
var parseFile = (file) => {
  const ast = parse(file.content, {
    sourceType: "module",
    plugins: ["jsx", "typescript", "classProperties", "decorators-legacy", "dynamicImport", "objectRestSpread", "optionalChaining", "nullishCoalescingOperator"]
  });
  return ast;
};
var toParsedFile = (file) => {
  return {
    ...file,
    ast: parseFile(file)
  };
};
var parseDirectory = async ({
  path: path3,
  extensions,
  ignore
}) => {
  const root = await readDir(path3, extensions, ignore);
  const transform = (file) => {
    if (file.type === "file") {
      return toParsedFile(file);
    } else if (file.type === "config") {
      return {
        type: "config",
        config: file.config
      };
    } else {
      const allChildren = file.children.map(transform);
      const configs = allChildren.filter((f) => f.type === "config");
      const children = allChildren.filter((f) => f.type !== "config");
      const parsedDirectory = {
        ...file,
        children,
        configs
      };
      parsedDirectory.children.forEach((child) => child.parent = parsedDirectory);
      return parsedDirectory;
    }
  };
  return transform(root);
};

// src/lib/printer.ts
import chalk2 from "chalk";
var printUnusedExports = (sourceFiles) => {
  let totalCount = 0;
  const filesWithUnusedExports = sourceFiles.filter((f) => {
    const unusedCount = f.moduleInfo?.unusedExports.length || 0;
    totalCount += unusedCount;
    return unusedCount;
  });
  if (filesWithUnusedExports.length > 0) {
    console.log(chalk2`{bgRedBright
{black {bold >> DEAD CODE DETECTED <<}}
{black >> in {bold ${filesWithUnusedExports.length}} files,}
{black >> {bold ${totalCount}} unused exports (suspected)}}
    `);
  }
  filesWithUnusedExports.forEach((file) => {
    const path3 = file.path.split("/").map((segm) => segm).join(chalk2.gray("/"));
    console.log(chalk2`{underline ${path3}}:\n {gray Unused exports:}\n ${file.moduleInfo.unusedExports.map((e) => e === "default" ? chalk2.bold.yellowBright(e) : chalk2.yellowBright(e)).join(", ")}`);
  });
};

// src/index.ts
program.name("no-dead-code").description("Search unused exports in your code").argument("[path]", "the path to begin search from", ".").option("--no-default-ignore", "specify to allow node_modules, .git, dist, build and migrations to be included").option("--no-node-stdlib", "specify to not resolve to node std APIs").option("--no-dev", "specify to not resolve dev dependecies").option("-i, --ignore <ignorePaths...>", "specify paths to ignore").option("-e, --extensions <extensions...>", "specify the extensions to include", ["mjs", "cjs", "js", "ts", "tsx", "jsx"]).parse();
var path2 = program.processedArgs[0];
var opts = program.opts();
(async () => {
  const extensions = opts.extensions ?? [];
  const ignore = opts.ignore ?? [];
  if (opts.defaultIgnore)
    ignore.push("node_modules", ".git", "dist", "build", "migrations");
  const result = await parseDirectory({
    path: path2,
    extensions,
    ignore
  });
  const standardLib = [];
  if (opts.nodeStdlib)
    standardLib.push("fs", "os", "path", "crypto", "events", "util", "net", "http", "https", "dns", "url", "child_process", "cluster", "process", "stream");
  const sourceFiles = analyse(result, standardLib, Boolean(opts.dev));
  if (sourceFiles.length === 0) {
    console.log("No source files found");
    return;
  }
  printUnusedExports(sourceFiles);
})();
